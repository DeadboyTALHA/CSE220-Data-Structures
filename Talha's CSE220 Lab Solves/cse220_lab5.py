# -*- coding: utf-8 -*-
"""CSE220 Lab5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10AWDg8VCs5GmmuwAJoSXtd1I6xd6T5l6
"""

class BTNode:
  def __init__(self, elem):
    self.elem = elem
    self.right = None
    self.left = None

def inorder(root):
  if root == None:
    return

  inorder(root.left)
  print(root.elem, end = ' ')
  inorder(root.right)

def tree_construction(arr, i = 1):
  if i>=len(arr) or arr[i] == None:
    return None
  p = BTNode(arr[i])
  p.left = tree_construction(arr, 2*i)
  p.right = tree_construction(arr, 2*i+1)
  return p


root2 = tree_construction([None, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', None, None, None, 'I', 'J', None, 'k'])
inorder(root2)

"""Task 1"""

def convert_mirror(root):
  #To Do
  if root == None:
    return None
  temp = root.right
  root.right = root.left
  root.left = temp
  convert_mirror(root.left)
  convert_mirror(root.right)
  return root


#DRIVER CODE
root = BTNode(10)
n1 = BTNode(20)
n2 = BTNode(30)
n3 = BTNode(40)
n4 = BTNode(60)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  40 20 60 10 30
print()

root2 = convert_mirror(root)
print('Mirrored Tree Inorder Traversal: ', end = ' ')
inorder(root2) #Mirrored Tree Inorder Traversal:  30 10 60 20 40

"""Task 2"""

def smallest_level(root, level = {}, i = 0):
  #To Do
  if root == None:
    return None
  if (i not in level) or level[i] > root.elem:
    level[i] = root.elem
  smallest_level(root.left, level, i + 1)
  smallest_level(root.right, level, i + 1)
  return level


#DRIVER CODE
root = tree_construction([None, 4,9,2,3,-5,None,7])
print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  3 9 5 4 2 7
print()
print('Level Wise Smallest Value: ', end = ' ')
print(smallest_level(root)) #Level Wise Smallest Value:  {0: 4, 1: 2, 2: -5}

"""Task 3"""

def sumTree(root):
  # To DO
  #you can declare as many helper function with extra parameters as you need .
  #You can not modify the parameters of sumTree or modify any part of the given code.
  if root == None:
    return 0
  lsum1 = helper(root.left, 1)
  rsum1 = helper(root.right, 1)
  return root.elem + lsum1 + rsum1
def helper(root, level):
  if root == None:
    return 0
  lsum2 = helper(root.left, level + 1)
  rsum2 = helper(root.right, level + 1)
  return (root.elem % level) + lsum2 + rsum2

#Driver Code
#Input 1
root1 = BTNode(9)
node2 = BTNode(4)
node3 = BTNode(5)
node4 = BTNode(18)
node5 = BTNode(14)
node6 = BTNode(3)
node7 = BTNode(54)
node8 = BTNode(12)
node9 = BTNode(8)
node10 = BTNode(91)
node11 = BTNode(56)

root1.left = node2
root1.right = node3

node2.left = node4

node3.left = node5
node3.right = node6

node4.left = node7
node4.right = node8

node5.left = node9

node8.left = node10
node8.right = node11

print(sumTree(root1)) #This should print 15

"""Task 4

"""

def swap_child(root, level, M):
  #To Do
  if root == None:
    return None
  if level < M:
    temp = root.left
    root.left = root.right
    root.right = temp
  swap_child(root.left, level + 1, M)
  swap_child(root.right, level + 1, M)
  return root


#Driver Code
root=BTNode('A')
#Write other nodes by yourself from the given tree of Doc File
n1 = BTNode('B')
n2 = BTNode('C')
n3 = BTNode('D')
n4 = BTNode('E')
n5 = BTNode('F')
n6 = BTNode('G')
n7 = BTNode('H')
n8 = BTNode('I')
n9 = BTNode('J')

root.left = n1
n1.left = n3
n1.right = n4
n3.left = n6
n3.right = n7
n4.left = n8
root.right = n2
n2.right = n5
n5.left = n9

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root)   #Given Tree Inorder Traversal: G D H B I E A C J F
print()

root2 = swap_child(root, 0, 2)
print('Swapped Tree Inorder Traversal: ', end = ' ')
inorder(root2)  #Swapped Tree Inorder Traversal: J F C A I E B G D H

"""Task 5"""

def subtract_summation(root):
  #To Do
  if root == None:
    return 0
  lsum1 = helper(root.left)
  rsum1 = helper(root.right)
  return lsum1 - rsum1
def helper(root):
  if root == None:
    return 0
  lsum2 = helper(root.left)
  rsum2 = helper(root.right)
  return root.elem + lsum2 + rsum2


#Driver Code
root=BTNode(71)
#Write other nodes by yourself from the given tree of Doc File
n1 = BTNode(27)
n2 = BTNode(62)
n3 = BTNode(80)
n4 = BTNode(75)
n5 = BTNode(41)
n6 = BTNode(3)
n7 = BTNode(87)
n8 = BTNode(56)
n9 = BTNode(19)
n10 = BTNode(89)

root.left = n1
n1.left = n3
n1.right = n4
n3.left = n7
n3.right = n8
root.right = n2
n2.left = n5
n2.right = n6
n6.left = n9
n6.right = n10
print(subtract_summation(root)) #This should print 111

"""Bonus Task"""

def level_sum(root):
  #To Do
  if root == None:
    return 0
  lsum1 = helper(root.left, 1)
  rsum1 = helper(root.right, 1)
  return lsum1 + rsum1 - root.elem
def helper(root, level):
  if root == None:
    return 0
  lsum2 = helper(root.left, level + 1)
  rsum2 = helper(root.right, level + 1)
  sum = lsum2 + rsum2
  if level % 2 == 0:
    return sum - root.elem
  else:
    return sum + root.elem


#DRIVER CODE
root = BTNode(1)
n2 = BTNode(2)
n3 = BTNode(3)
n4 = BTNode(4)
n5 = BTNode(5)
n6 = BTNode(6)
n7 = BTNode(7)
n8 = BTNode(8)
root.left = n2
root.right = n3

n2.left = n4
n3.left = n5
n3.right = n6

n5.left = n7
n5.right = n8


print(level_sum(root)) #This should print 4