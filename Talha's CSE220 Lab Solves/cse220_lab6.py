# -*- coding: utf-8 -*-
"""CSE220 Lab6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rMCKuYN9eCN3UryYOHhLoaOwEKIddvQM
"""

class BTNode:
  def __init__(self, elem):
    self.elem = elem
    self.right = None
    self.left = None

def inorder(root):
  if root == None:
    return

  inorder(root.left)
  print(root.elem, end = ' ')
  inorder(root.right)

def tree_construction(arr, i = 1):
  if i>=len(arr) or arr[i] == None:
    return None
  p = BTNode(arr[i])
  p.left = tree_construction(arr, 2*i)
  p.right = tree_construction(arr, 2*i+1)
  return p


root2 = tree_construction([None, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', None, None, None, 'I', 'J', None, 'k'])
inorder(root2)

"""Task 1"""

def LCA(root, x, y):
  #To Do
  if root == None:
    return None
  if root.elem > x and root.elem > y:
    return LCA(root.left, x, y)
  if root.elem < x and root.elem < y:
    return LCA(root.right, x, y)
  return root.elem


#DRIVER CODE
root = BTNode(15)
root.left = BTNode(10)
root.left.left = BTNode(8)
root.left.right = BTNode(12)
root.left.left.left = BTNode(6)
root.left.left.right = BTNode(9)
root.right = BTNode(25)
root.right.left = BTNode(20)
root.right.right = BTNode(30)
root.right.left.left = BTNode(18)
root.right.left.right = BTNode(22)
print(LCA(root, 6, 12)) #10
print(LCA(root, 20, 6)) #15
print(LCA(root, 18, 22)) #20
print(LCA(root, 20, 25)) #25
print(LCA(root, 10, 12)) #10
#Write by yourself from the given tree (Create parent node and its corresponding left and right children nodes)
#check all the sample inputs given
#You can take help by seeing the driver code of Lab-6

"""Task 2"""

def find_Path(root, key):
  #To Do
  if root == None:
    return None
  if root.elem == key:
    return [root.elem]
  if key < root.elem:
    path = find_Path(root.left, key)
  else:
    path = find_Path(root.right, key)
  if path == None or path == 'No Path Found':
    return 'No Path Found'
  else:
    return [root.elem] + path


#DRIVER CODE
#Write by yourself from the given tree
root = BTNode(30)
n1 = BTNode(10)
n2 = BTNode(40)
n3 = BTNode(3)
n4 = BTNode(15)
n5 = BTNode(35)
n6 = BTNode(55)
root.left = n1
root.right = n2
n1.left = n3
n1.right = n4
n2.left = n5
n2.right = n6


print(find_Path(root,15))
#This should print [30,10,15]
print(find_Path(root,50))
#This should print No Path Found

"""Task 3"""

def sum_of_leaves(root, sum):
  #To Do
  if root == None:
    return 0
  if root.left == None and root.right == None:
    sum += root.elem
    return sum
  return sum_of_leaves(root.left, sum) + sum_of_leaves(root.right, sum)


#DRIVER CODE
#Write by yourself from the given tree
root = BTNode(30)
n1 = BTNode(10)
n2 = BTNode(40)
n3 = BTNode(3)
n4 = BTNode(15)
n5 = BTNode(35)
n6 = BTNode(55)
n7 = BTNode(2)
n8 = BTNode(36)
root.left = n1
root.right = n2
n1.left = n3
n1.right = n4
n2.left = n5
n2.right = n6
n3.left = n7
n5.right = n8


print(sum_of_leaves(root, 0))

"""Task 4"""

def inorder_predecessor(root, x):
  #To Do
  pred = None
  tail = root
  while tail != None:
    if x.elem > tail.elem:
      pred = tail
      tail = tail.right
    elif x.elem < tail.elem:
      tail = tail.left
    else:
      if tail.left != None:
        temp = tail.left
        while temp.right != None:
          temp = temp.right
        pred = temp
      break
  return pred


#DRIVER CODE
root = BTNode(20)
n1 = BTNode(8)
n2 = BTNode(22)
n3 = BTNode(4)
n4 = BTNode(12)
n5 = BTNode(10)
n6 = BTNode(14)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n4.left = n5
n4.right = n6

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  4 8 10 12 14 20 22
print()

x = root
print(f'Inorder predecessor of node {x.elem}: {inorder_predecessor(root, x).elem}') #Inorder predecessor of node 20: 14
x = root.left.right.right
print(f'Inorder predecessor of node {x.elem}: {inorder_predecessor(root, x).elem}') #Inorder predecessor of node 14: 12
x = root.left.right.left
print(f'Inorder predecessor of node {x.elem}: {inorder_predecessor(root, x).elem}') #Inorder predecessor of node 10: 8