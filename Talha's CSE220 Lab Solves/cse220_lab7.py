# -*- coding: utf-8 -*-
"""CSE220 Lab7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QTCmMMJ8R96hvmrcn_N10aYuw9yrxF65
"""

#Task - 1
class MinHeap:

  def __init__(self, capacity):
    self.capacity = capacity
    self.__heap = [None] * self.capacity
    self.__size = 0

  def insert(self, val):
    if val == None:
      return None
    if self.__size == self.capacity:
      print("Overflow")
    self.__heap[self.__size] = val
    self.swim(self.__size)
    self.__size += 1

  def sort(self):
    ans = []
    temp = self.__size
    for i in range(temp):
      min = self.extractMin()
      ans += [min]
    self.__size = temp
    return ans

  def extractMin(self):
    if self.__size == 0:
      print("Empty")
    min_val = self.__heap[0]
    self.__size -= 1
    self.__heap[0] = self.__heap[self.__size]
    self.__heap[self.__size] = None
    self.sink(0)
    return min_val

  def swim(self, i):
    while i > 0 and self.__heap[i]!=0:
      head = (i - 1) // 2
      if self.__heap[head] > self.__heap[i]:
        temp = self.__heap[i]
        self.__heap[i] = self.__heap[head]
        self.__heap[head] = temp
        i = head
      else:
        break

  def sink(self, i):
    while (2 * i + 1) < self.__size:
      p = i
      c1 = 2 * i + 1
      c2 = 2 * i + 2
      if (c1 < self.__size) and (self.__heap[c1] != None) and (self.__heap[c1] < self.__heap[p]):
        p = c1
      if (c2 < self.__size) and (self.__heap[c2] != None) and (self.__heap[c2] < self.__heap[p]):
        p = c2
      if p == i:
        break
      temp = self.__heap[i]
      self.__heap[i] = self.__heap[p]
      self.__heap[p] = temp
      i = p


#Driver Code
arr = [3, 2, 5, 1, 4, 6, None]
min_heap = MinHeap(len(arr) - 1)
for i in arr:
  min_heap.insert(i)
print("Sorted MinHeap:")
print(min_heap.sort())


arr1 = [3, 2, 5, None, 4, 6, 7, None, None, None, 8]
min_heap1 = MinHeap(len(arr1) - 1)
for i in arr1:
  min_heap1.insert(i)
print("Sorted MinHeap:")
print(min_heap1.sort())

#Task - 2
class MaxHeap:

  def __init__(self, capacity):
    self.capacity = capacity
    self.__heap = [None] * capacity
    self.__size = 0

  def insert(self, val):
    if val == None:
      return None
    if self.__size == self.capacity:
      print("Overflow")
    self.__heap[self.__size] = val
    self.swim(self.__size)
    self.__size += 1

  def sort(self):
    ans = []
    temp = self.__size
    for i in range(temp):
      max = self.extractMax()
      ans += [max]
    self.__size = temp
    return ans

  def extractMax(self):
    if self.__size == 0:
      print("Empty")
    max_val = self.__heap[0]
    self.__size -= 1
    self.__heap[0] = self.__heap[self.__size]
    self.__heap[self.__size] = None
    self.sink(0)
    return max_val

  def swim(self, i):
    while i > 0 and self.__heap[i]!=0:
      head = (i - 1) // 2
      if self.__heap[i] > self.__heap[head]:
        temp = self.__heap[i]
        self.__heap[i] = self.__heap[head]
        self.__heap[head] = temp
        i = head
      else:
        break

  def sink(self, i):
    while (2 * i + 1) < self.__size:
      p = i
      c1 = 2 * i + 1
      c2 = 2 * i + 2
      if (c1 < self.__size) and (self.__heap[c1] > self.__heap[p]):
        p = c1
      if (c2 < self.__size) and (self.__heap[c2] > self.__heap[p]):
        p = c2
      if p == i:
        break
      temp = self.__heap[i]
      self.__heap[i] = self.__heap[p]
      self.__heap[p] = temp
      i = p


#Driver Code
arr = [3, 2, 5, 1, 4, 6, None]
max_heap = MaxHeap(len(arr)-1)
for i in arr:
  max_heap.insert(i)
print("Sorted MaxHeap:")
print(max_heap.sort())


arr1 = [3, 2, 5, None, 4, 6, 7, None, None, None, 8]
max_heap1 = MaxHeap(len(arr1)-1)
for i in arr1:
  max_heap1.insert(i)
print("Sorted MaxHeap:")
print(max_heap1.sort())

#Task - 3
def distributeTasks(tasks, m):
  loads = MinHeap(m)
  for i in range(m):
    loads.insert(tasks[i])
  while m < len(tasks):
    min_val = loads.extractMin() + tasks[m]
    loads.insert(min_val)
    m += 1
  ans = loads.sort()
  return ans

result = distributeTasks([2, 4, 7, 1, 6], 4)
print(f"Distributed Loads: {result}")

#Task - 4
def findTopKLargest(nums, k):
  top = MaxHeap(len(nums))
  ans = []
  for i in nums:
    top.insert(i)
  for j in range(k):
    max_val = top.extractMax()
    ans += [max_val]
  return ans

result = findTopKLargest([4, 10, 2, 8, 6, 7], 3)
print(f"Top K Largest: {result}")